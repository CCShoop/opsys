OS/161
1.	A system call is called when a program is run on an operating system. When a user-level program calls a system call, control is transferred from the user level through the system call after an interruption that is trapped and stored in a trapframe to kernel level. It is here that the program is given an ID and allocated memory to be run by the CPU.
2.	sys_reboot() is an example of a system call in OS/161.
3.	Limited Direct Execution is a simpler version of system calls, where the process receives a process entry in a process list, memory is allocated for the program code, entry point is located and jumped to, and runs the code.
4.	To add a system call to OS/161, you must add the kernel-level implementation and then the user-level implementation. The program is placed in kern/syscall, then its calls implemented throughout the kernel level.
5.	To debug OS/161, the OS must be run through gdb. Breakpoints can be placed to move throughout the OS for debugging purposes.
6.	The user-level syscall code interacts directly with kern-level syscall code to pass function arguments using the trapframe and a mips exception.
7.	Ready, Running, Blocked, Sleeping, Zombie
Ready: Ready to be run by CPU
Running: Being run by CPU
Blocked: Waiting for I/O, cannot continue
Sleeping: Yields control to next thread and takes control again when wakeup() is called
Zombie: Process left over when thread is exited
8.	When a thread terminates, the process will continue if it has other threads.
thread_exit(): removes virtual memory space and decrements counter


Process Abstraction
1. Running to Ready: when an interrupt is generated or the scheduler algorithm swaps out the current running process.
2. Blocked to Running: the program receives what it requires to continue, such as I/O
3. The process address space consists of at least three segments: text, data, and stack.


Process API
1. Output:
hello world (pid:1223)
I am parent of 1224 (pid:1223)
I am child (pid:1224)
2. A wait() called by a child with no child will have no effect.
3. Yes, both can write to the file. The parent closing the file will not affect the child's ability to access it.
4. Nothing, but yes, because the child process will not affect the parent process.
5. 14 times. (3 loops; 2, 4, and 8 hellos; 2+4+8=14)
6. It will close stdout and not print anything.
7. It will wait for the grandchild to terminate, but it does not exist and it will be stuck.
8. It will have an error and print nothing.
9. The course name is written to the file.
10. It will print the current directory or wait for the child to terminate and print the course name.

Limited Direct Execution
1. It calls the hardlock method and thread_yield is called.
2. Multiprogramming is two or more processes sharing memory and a processor core.


A trap is an exception in a user process. It's caused by division by zero or invalid memory access. It's also the usual way to invoke a kernel routine (a system call) because those run with a higher priority than user code. Handling is synchronous (so the user code is suspended and continues afterwards). In a sense they are "active" - most of the time, the code expects the trap to happen and relies on this fact.
You can also see a trap as a kind of CPU-internal interrupt since the handler for trap handler looks like an interrupt handler (registers and stack pointers are saved, there is a context switch, execution can resume in some cases where it left off).

An interrupt is something generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc). These are asynchronous (i.e. they don't happen at predictable places in the user code) or "passive" since the interrupt handler has to wait for them to happen eventually.

